name: copilot-listener
apiRevision: edurata.io/v1
description: |
  Listens to the mail inbox for new messages and responds to them with a generated response.
interface:
  inputs:
    type: object
    properties:
      fromDomain:
        type: string
        default: mail.kleinanzeigen.de
        description: Domain to filter emails from (e.g., mail.kleinanzeigen.de will match anything@mail.kleinanzeigen.de)
      maxResults:
        type: integer
        default: 10
        description: Maximum number of emails to retrieve
      airtable_base_id:
        type: string
        description: Airtable base ID to fetch data from
      airtable_table_id:
        type: string
        description: Airtable table ID to fetch data from
      airtable_filter_field:
        type: string
        default: threadId
        description: Field name in Airtable to filter by (e.g., 'threadId', 'messageId', or 'email')
      primary_key_regex:
        type: string
        description: Regex pattern with a capturing group to extract the primary key from email body (e.g., 'Anzeige-ID:\\s*([A-Z0-9]+)')
      message_regex:
        type: string
        description: Regex pattern with a capturing group to extract the message content from email body (e.g., 'Nachricht:\\s*(.+?)(?:\\n\\n|$)')
      listenerId:
        type: string
        description: ID of the copilot listener that triggered this workflow execution
      listenerEmail:
        type: string
        description: Optional email of the listener (e.g. mailbox address) to set messages[].role and messages[].direction (outgoing = from this address, incoming = from others)
      userInfo:
        type: string
        description: User information to use for the response
      customCategories:
        type: array
        items:
          type: object
          properties:
            name:
              type: string
              description: Category name
            description:
              type: string
              description: Category description
            possibleValues:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                    description: Possible value name
                  color:
                    type: string
                    description: Possible value color
        description: Custom categories to add to the draft
  outputs:
    type: object
    properties: {}
steps:
  ensure-outlook-categories:
    if:
      "!!": ${inputs.customCategories}
    description: |
      Erstellt fehlende Outlook-Kategorien im Format name:value aus customCategories (lazy),
      damit sie beim Entwurf-Erstellen verfügbar sind.
    runtime: python3_10
    code: |
      import json
      import urllib.request
      import urllib.error
      def handler(inputs):
          custom_categories = inputs.get("customCategories") or []
          token = (inputs.get("outlook_api_key") or "").strip()
          if not token or not custom_categories:
              return {"created": [], "existing": []}
          base = "https://graph.microsoft.com/v1.0/me/outlook/masterCategories"
          headers = {"Authorization": "Bearer " + token, "Content-Type": "application/json"}
          existing = set()
          try:
              req = urllib.request.Request(base, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  data = json.loads(resp.read().decode())
              for c in data.get("value", []):
                  existing.add((c.get("displayName") or "").strip())
          except Exception:
              pass
          desired = []
          for cat in custom_categories:
              cat_name = (cat.get("name") or "").strip()
              if not cat_name:
                  continue
              for pv in (cat.get("possibleValues") or []):
                  val_name = (pv.get("name") or "").strip() if isinstance(pv, dict) else str(pv).strip()
                  if not val_name:
                      continue
                  display_name = cat_name + ":" + val_name
                  color = (pv.get("color") or "preset0").strip() if isinstance(pv, dict) else "preset0"
                  if not color.startswith("preset"):
                      color = "preset0"
                  desired.append((display_name, color))
          created = []
          for display_name, color in desired:
              if display_name in existing:
                  continue
              try:
                  body = json.dumps({"displayName": display_name, "color": color}).encode()
                  req = urllib.request.Request(base, data=body, headers=headers, method="POST")
                  with urllib.request.urlopen(req) as resp:
                      created.append(display_name)
                      existing.add(display_name)
              except urllib.error.HTTPError as e:
                  if e.code != 409:
                      raise
              except Exception:
                  pass
          return {"created": created, "existing": list(existing)}
    props:
      customCategories: ${inputs.customCategories}
      outlook_api_key: ${secrets.copilot-outlook-oauth}
  get-outlook-unanswered:
    description: |
      Holt unbeantwortete Outlook-Nachrichten von der Absender-Domain (ohne Entwurf und ohne gesendete Antwort).
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: etl/load/list-outlook-unanswered
    props:
      OUTLOOK_API_KEY: ${secrets.copilot-outlook-oauth}
      senderDomain: ${inputs.fromDomain}
      top: ${inputs.maxResults}

  get-outlook-conversation:
    description: |
      Holt alle Nachrichten einer Konversation (Thread) per Microsoft Graph API.
    foreach: ${get-outlook-unanswered.messages}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: GET
      url: https://graph.microsoft.com/v1.0/me/messages
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      params:
        $filter: "conversationId eq '${each.conversationId}'"
        $select: id,body,from,receivedDateTime,subject
        $orderby: receivedDateTime asc
        $top: 100

  extract-outlook-conversation-info:
    description: |
      Wendet primary_key_regex und message_regex auf alle Nachrichten der Konversation an;
      bei fehlendem Treffer wird der gesamte Nachrichtentext verwendet.
      Gibt primaryKey und messages zurück (content, index, from, role, direction).
      direction: incoming = von außen, outgoing = vom Listener; letzter Eintrag = neueste Nachricht.
    foreach: ${get-outlook-unanswered.messages}
    runtime: python3_10
    code: |
      import re
      def handler(inputs):
          conversation_messages = inputs.get("conversationMessages") or []
          primary_key_regex = inputs.get("primary_key_regex") or ""
          message_regex = inputs.get("message_regex") or ""
          listener_email = (inputs.get("listenerEmail") or "").strip().lower()
          primary_key = ""
          messages = []
          for idx, msg in enumerate(conversation_messages):
              body = msg.get("body")
              content = body if isinstance(body, str) else ((body or {}).get("content") or "")
              if message_regex:
                  m = re.search(message_regex, content, re.MULTILINE | re.DOTALL)
                  part = (m.group(1) if m and m.groups() else (m.group(0) if m else content)).strip() if m else content
              else:
                  part = content
              from_obj = msg.get("from") or {}
              email_addr = (from_obj.get("emailAddress") or {}).get("address") or ""
              is_outgoing = bool(listener_email and email_addr.lower() == listener_email)
              role = "assistant" if is_outgoing else "user"
              direction = "outgoing" if is_outgoing else "incoming"
              messages.append({"content": part, "index": idx, "from": email_addr or None, "role": role, "direction": direction})
              if not primary_key and primary_key_regex:
                  pk = re.search(primary_key_regex, content, re.MULTILINE | re.DOTALL)
                  if pk:
                      primary_key = pk.group(1) if pk.groups() else pk.group(0)
          return {"primaryKey": primary_key, "messages": messages}
    props:
      conversationMessages: ${get-outlook-conversation[each.index].response.data.value}
      primary_key_regex: ${inputs.primary_key_regex}
      message_regex: ${inputs.message_regex}
      listenerEmail: ${inputs.listenerEmail}

  fetch-airtable-data-outlook:
    if:
      "!!": ${inputs.airtable_base_id}
    description: |
      Holt Airtable-Daten für jede Konversation anhand des extrahierten Primary Key.
    foreach: ${extract-outlook-conversation-info[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: GET
      url: https://api.airtable.com/v0/${inputs.airtable_base_id}/${inputs.airtable_table_id}
      headers:
        Authorization: Bearer ${secrets.copilot-airtable-api-key}
      params:
        filterByFormula: "{${inputs.airtable_filter_field}} = '${each.primaryKey}'"

  generate-ai-responses-outlook:
    description: |
      Ruft Copilot-API getReplyToMessage auf (threadId, messageId, listenerId, conversationHistory, optional primaryKey/airtableData).
      Alle Nachrichten in conversationHistory; letzter Eintrag = neueste Nachricht. Kein messageContent.
    foreach: ${get-outlook-unanswered.messages}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: POST
      url: ${inputs.copilotApiUrl}/copilot/generate-response
      headers:
        Authorization: Bearer ${secrets.copilot-execution-token}
        Content-Type: application/json
      body:
        threadId: ${each.conversationId}
        messageId: ${each.id}
        listenerId: ${inputs.listenerId}
        conversationHistory: ${extract-outlook-conversation-info[each.index].messages}
        primaryKey: ${extract-outlook-conversation-info[each.index].primaryKey}
        airtableData: ${fetch-airtable-data-outlook[each.index].response.data}

  prepare-outlook-draft-content:
    description: |
      Mappt AI-Antwort auf Entwurf-Inhalt: reply als body, categories-Objekt auf displayNames (name:value),
      damit sie mit ensure-outlook-categories übereinstimmen (keine ID-Mapping nötig).
      Akzeptiert Copilot-API-Format (reply, parsedJson) oder direkt (reply, categories).
    foreach: ${generate-ai-responses-outlook[*]}
    runtime: python3_10
    code: |
      def handler(inputs):
          ai_response = inputs.get("aiResponse") or {}
          original_message_id = (inputs.get("originalMessageId") or "").strip()
          conversation_id = (inputs.get("conversationId") or "").strip()
          processed_label = (inputs.get("processedLabel") or "").strip()
          body = (ai_response.get("reply") or "").strip()
          cats_obj = ai_response.get("categories")
          if cats_obj is None and "parsedJson" in ai_response:
              pj = ai_response.get("parsedJson") or {}
              cats_obj = pj.get("categories") if isinstance(pj, dict) else pj
          categories = [processed_label] if processed_label else []
          if isinstance(cats_obj, dict):
              for name, value in cats_obj.items():
                  if name and value:
                      categories.append(str(name).strip() + ":" + str(value).strip())
          return {
              "body": body,
              "categories": categories,
              "originalMessageId": original_message_id,
              "conversationId": conversation_id,
          }
    props:
      aiResponse: ${each.response.data}
      originalMessageId: ${get-outlook-unanswered.messages[each.index].id}
      conversationId: ${get-outlook-unanswered.messages[each.index].conversationId}
      processedLabel: ${inputs.processedLabel}

  create-outlook-reply-draft:
    description: |
      Erstellt den Reply-Entwurf (Graph createReply). createReply nimmt keinen Body;
      Body/Kategorien werden im nächsten Schritt per PATCH gesetzt.
    foreach: ${prepare-outlook-draft-content[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: POST
      url: https://graph.microsoft.com/v1.0/me/messages/${each.originalMessageId}/createReply
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      body: {}

  update-outlook-draft:
    description: |
      Setzt Body, Kategorien und isReplyTo auf dem Entwurf (kein extensionMetadata).
    foreach: ${create-outlook-reply-draft[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: PATCH
      url: https://graph.microsoft.com/v1.0/me/messages/${each.response.data.id}
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      body:
        body:
          contentType: HTML
          content: ${prepare-outlook-draft-content[each.index].body}
        categories: ${prepare-outlook-draft-content[each.index].categories}
        singleValueExtendedProperties:
          - id: "String {66f5a359-4659-4830-9070-00047ec6ac6e} Name isReplyTo"
            value: ${prepare-outlook-draft-content[each.index].originalMessageId}

