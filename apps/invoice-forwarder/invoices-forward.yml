apiRevision: edurata.io/v1
name: invoice-processor
title: Invoice Processor
schedule: "0 9 * * *"
description: |
  Searches through the inbox and saves, tags and forwards invoices
interface:
  inputs:
    properties:
      peopleTableId:
        type: string
        description: |
          The base id + table_id from which to take the people
      userEmail:
        type: string
        description: |
          The email address of the user
      config:
        type: object
        description: |
          The configuration of the invoice processor
        properties:
          gdriveFolderId:
            type: string
            description: |
              The Google Drive folder ID to save the invoices to
          forwardEmail:
            type: string
            description: |
              The email address to forward the invoices to
          successTag:
            type: string
            default: "to-datev/processed"
          failTag:
            type: string
            default: "to-datev/failed"
          skipTag:
            type: string
            default: "to-datev/skipped"
          additionalQuery:
            type: string
            description: |
              Additional query to filter the emails
            default: ""
    required:
      - config
      - userEmail
      - peopleTableId
inputs:
  config: ${variables.invoices_forward_config}
  peopleTableId: ${variables.accountingbot_people_table_id}
steps:
  get-people-data:
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      url: 'https://api.airtable.com/v0/${inputs.peopleTableId}?filterByFormula=AND(NOT(disabled),{email}="${inputs.userEmail}")'
      headers:
        Authorization: "Bearer ${secrets.AIRTABLE_API_KEY}"
  merge-config:
    runtime: python3_10
    code: |
      def handler(inputs):
          user_config = inputs["user_config"]
          base_config = inputs["base_config"]
          # merge both together
          merged = {**base_config, **user_config}
          return  {"config": merged}
    dependencies:
      user_config: ${get-people-data.response.data.records[0].fields}
      base_config: ${inputs.config}
  create-labels:
    foreach: 
      - ${merge-config.config.successTag}
      - ${merge-config.config.failTag}
      - ${merge-config.config.skipTag}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      url: https://gmail.googleapis.com/gmail/v1/users/me/labels
      method: POST
      headers:
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      data:
        name: ${each}
  get-label-ids:
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      url: https://gmail.googleapis.com/gmail/v1/users/me/labels
      headers:
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      __create-labels: ${create-labels}
  transform-tags-to-label-ids:
    runtime: python3_10
    code: |
      def handler(inputs):
          label_ids = {}
          for label in inputs["get-label-ids"]["response"]["data"]["labels"]:
            if label["name"] == inputs["successTag"]:
              label_ids["successTag"] = label["id"]
            elif label["name"] == inputs["failTag"]:
              label_ids["failTag"] = label["id"]
            elif label["name"] == inputs["skipTag"]:
              label_ids["skipTag"] = label["id"]
          return {"label_ids": label_ids}
    dependencies:
      get-label-ids: ${get-label-ids}
      successTag: ${merge-config.config.successTag}
      failTag: ${merge-config.config.failTag}
      skipTag: ${merge-config.config.skipTag}
  # filter people for interval and today's day
  get-new-mails-without-tag:
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      url: https://www.googleapis.com/gmail/v1/users/me/messages
      headers:
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      params:
        q: "after:2021/01/01 ${merge-config.config.additionalQuery} -label:${merge-config.config.successTag} -label:${merge-config.config.failTag} -label:${merge-config.config.skipTag} has:attachment filename:pdf" 
        maxResults: 10
      __create-labels: ${create-labels}
  get-mails-info:
    foreach: ${get-new-mails-without-tag.response.data.messages}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      url: https://gmail.googleapis.com/gmail/v1/users/me/messages/${each.id}
      headers:
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      params:
        format: "full"
        fields: "id,payload"
  filter-attachments:
    source:
      repoUrl: "https://github.com/Edurata/edurata-workflows.git"
      path: apps/invoice-forwarder/filter-attachments
    dependencies:
      messages: ${get-mails-info[*].response.data}
  download-attachments:
    foreach: ${filter-attachments.filtered_attachments}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      url: "https://gmail.googleapis.com/gmail/v1/users/me/messages/${each.message_id}/attachments/${each.attachment_id}"
      headers:
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
  save-attachments:
    runtime: python3_10
    dependencies:
      attachments_data: ${download-attachments[*].response.data}
    interface:
      inputs:
        properties:
          attachments_data:
            type: array
            items: 
              type: object
              properties:
                attachmentId:
                  type: string
                  description: |
                    The name of the attachment
                data:
                  type: string
            description: |
              The data of the attachments
      outputs:
        properties:
          new_files:
            type: array
            items:
              type: file
              description: |
                The new file name
    code: |
      import base64
      import uuid

      def correct_base64url_padding(data):
          # Add padding if necessary
          padding_needed = 4 - (len(data) % 4)
          if padding_needed and padding_needed < 4:
              data += '=' * padding_needed
          return data

      def handler(inputs):
          new_files = []
          for attachment_data in inputs["attachments_data"]:
              try:
                  # Correct the base64url padding
                  corrected_data = correct_base64url_padding(attachment_data["data"])
                  random_id = str(uuid.uuid4())
                  new_file = f"/tmp/{random_id}.pdf"
                  with open(new_file, "wb") as f:
                      f.write(base64.urlsafe_b64decode(corrected_data))
                  new_files.append(new_file)
              except (base64.binascii.Error, IOError) as e:
                  print(f"Error processing attachment: {e}")
                  # Handle the error as needed, e.g., skip the file or return an error response
          return {"new_files": new_files}
  forward-pdf:
    foreach: ${save-attachments.new_files}
    if: ${merge-config.config.forwardEmail} !== undefined
    description: |
      Forward the PDF attachments to the specified email address
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: etl/load/send-ses
    dependencies:
      sender: ${merge-config.config.sender_email}
      to: ${merge-config.config.forwardEmail}
      subject: "Invoice"
      html_body: "Please find the attached invoice"
      attachments: 
        - ${each}
      AWS_REGION: "eu-central-1"
      AWS_ACCESS_KEY_ID: ${secrets.SHORT_STORY_KEY}
      AWS_SECRET_ACCESS_KEY: ${secrets.SHORT_STORY_SECRET}
  get-folder-id:
    runtime: python3_10
    if: ${merge-config.config.gdriveFolderId} !== undefined
    code: |
      import datetime
      def handler(inputs):
          # today date like 2021-01-01
          today = datetime.datetime.now().strftime("%Y-%m-%d")
          return {"folder_name": today}
  create-folder-in-gdrive:
    if: ${merge-config.config.gdriveFolderId} !== undefined
    description: |
      Archive the PDF attachments in the specified Google Drive folder
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      method: POST
      url: "https://www.googleapis.com/drive/v3/files"
      headers:
        Content-type: "application/pdf"
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      data:
        name: "${get-folder-id.folder_name}"
        mimeType: "application/vnd.google-apps.folder"
        parents: ["${merge-config.config.gdriveFolderId}"]
  create-files-in-gdrive:
    foreach: ${filter-attachments.filtered_attachments}
    if: ${merge-config.config.gdriveFolderId} !== undefined
    description: |
      Archive the PDF attachments in the specified Google Drive folder
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      method: POST
      url: "https://www.googleapis.com/drive/v3/files"
      headers:
        Content-type: "application/pdf"
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      data:
        name: "${each.attachment_id}"
        mimeType: "application/vnd.google-apps.file"
        parents: ["${create-folder-in-gdrive.response.data.id}"]
  upload-files-in-gdrive:
    foreach: ${save-attachments.new_files}
    if: ${merge-config.config.gdriveFolderId} !== undefined
    description: |
      Archive the PDF attachments in the specified Google Drive folder
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      method: POST
      url: "https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
      headers:
        Content-type: "application/pdf"
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      dataFromFile: ${each}
  map-tags-to-threads:
    runtime: python3_10
    code: |
      def handler(inputs):
          thread_to_tags = {}
          for message in inputs["all_messages"]:
              thread_id = message["threadId"]

              # continue if already processed
              if thread_id in thread_to_tags:
                  continue

              is_in_filtered_attachments = False
              for attachment in inputs["filtered_attachments"]:
                  if attachment["message_id"] == message["id"]:
                      is_in_filtered_attachments = True
                      break
              thread_to_tags[thread_id] = inputs["successTag"] if is_in_filtered_attachments else inputs["skipTag"]
          
          # make into list of objects
          return [{"threadId": thread_id, "tag": tag} for thread_id, tag in thread_to_tags.items()]
    dependencies:
      all_messages: ${get-new-mails-without-tag.response.data.messages}
      filtered_attachments: ${filter-attachments.filtered_attachments} 
      successTag: ${transform-tags-to-label-ids.label_ids.successTag}
      failTag: ${transform-tags-to-label-ids.label_ids.failTag}
      skipTag: ${transform-tags-to-label-ids.label_ids.skipTag}
  tag-emails:
    foreach: ${map-tags-to-threads}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    dependencies:
      method: POST
      url: "https://gmail.googleapis.com/gmail/v1/users/me/threads/${each.threadId}/modify"
      headers:
        Authorization: "Bearer ${secrets.GMAIL_API_KEY}"
      data:
        addLabelIds: 
          - ${each.tag}
        removeLabelIds: []
        