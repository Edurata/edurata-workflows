name: copilot-listener
apiRevision: edurata.io/v1
description: |
  Listens to the mail inbox for new messages and responds to them with a generated response.
interface:
  inputs:
    type: object
    properties:
      fromDomain:
        type: string
        default: mail.kleinanzeigen.de
        description: Domain to filter emails from (e.g., mail.kleinanzeigen.de will match anything@mail.kleinanzeigen.de)
      maxResults:
        type: integer
        default: 10
        description: Maximum number of emails to retrieve
      airtable_base_id:
        type: string
        description: Airtable base ID to fetch data from
      airtable_table_id:
        type: string
        description: Airtable table ID to fetch data from
      airtable_filter_field:
        type: string
        default: threadId
        description: Field name in Airtable to filter by (e.g., 'threadId', 'messageId', or 'email')
      primary_key_regex:
        type: string
        description: Regex pattern with a capturing group to extract the primary key from email body (e.g., 'Anzeige-ID:\\s*([A-Z0-9]+)')
      message_regex:
        type: array
        items:
          type: string
        description: |
          List of regex patterns (each with optional capturing group); each is tried in order against the message body and the first match is used to extract message content.
      listenerId:
        type: string
        description: ID of the copilot listener that triggered this workflow execution
      listenerEmail:
        type: string
        description: Optional email of the listener (e.g. mailbox address) to set messages[].role and messages[].direction (outgoing = from this address, incoming = from others)
      customCategories:
        type: array
        items:
          type: object
          properties:
            name:
              type: string
              description: Category name
            description:
              type: string
              description: Category description
            possibleValues:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                    description: Possible value name
                  color:
                    type: string
                    description: Possible value color
        description: Custom categories to add to the draft
  outputs:
    type: object
    properties: {}
steps:
  ensure-outlook-categories:
    if:
      "!!": ${inputs.customCategories}
    description: |
      Erstellt fehlende Outlook-Kategorien (name:value aus customCategories), damit sie beim Entwurf-Erstellen verfügbar sind.
    runtime: python3_10
    code: |
      import json
      import urllib.request
      import urllib.error
      def handler(inputs):
          custom_categories = inputs.get("customCategories") or []
          token = (inputs.get("outlook_api_key") or "").strip()
          if not token or not custom_categories:
              return {"created": [], "existing": []}
          base = "https://graph.microsoft.com/v1.0/me/outlook/masterCategories"
          headers = {"Authorization": "Bearer " + token, "Content-Type": "application/json"}
          existing = set()
          try:
              req = urllib.request.Request(base, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  data = json.loads(resp.read().decode())
              for c in data.get("value", []):
                  existing.add((c.get("displayName") or "").strip())
          except Exception:
              pass
          desired = []
          for cat in custom_categories:
              cat_name = (cat.get("name") or "").strip()
              if not cat_name:
                  continue
              for pv in (cat.get("possibleValues") or []):
                  val_name = (pv.get("name") or "").strip() if isinstance(pv, dict) else str(pv).strip()
                  if not val_name:
                      continue
                  display_name = cat_name + ":" + val_name
                  color = (pv.get("color") or "preset0").strip() if isinstance(pv, dict) else "preset0"
                  if not color.startswith("preset"):
                      color = "preset0"
                  desired.append((display_name, color))
          created = []
          for display_name, color in desired:
              if display_name in existing:
                  continue
              try:
                  body = json.dumps({"displayName": display_name, "color": color}).encode()
                  req = urllib.request.Request(base, data=body, headers=headers, method="POST")
                  with urllib.request.urlopen(req) as resp:
                      created.append(display_name)
                      existing.add(display_name)
              except urllib.error.HTTPError as e:
                  if e.code != 409:
                      raise
              except Exception:
                  pass
          return {"created": created, "existing": list(existing)}
    props:
      customCategories: ${inputs.customCategories}
      outlook_api_key: ${secrets.copilot-outlook-oauth}
  get-outlook-unanswered:
    description: |
      Holt unbeantwortete Outlook-Konversationen von der Absender-Domain (rolling time window).
      Unbeantwortet = keine gesendete Antwort nach letzter Inbound-Nachricht im Fenster, und kein/veralteter Entwurf.
    source:
      repoUrl: "https://github.com/Edurata/edurata-workflows.git"
      path: internals/list-outlook-unanswered
    props:
      OUTLOOK_API_KEY: ${secrets.copilot-outlook-oauth}
      senderDomain: ${inputs.fromDomain}
      maxUnanswered: ${inputs.maxResults}

  get-outlook-conversation:
    description: |
      Holt die letzten n Nachrichten einer Konversation (Thread) per list-outlook-conversation.
    foreach: ${get-outlook-unanswered.unansweredConversationIds}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: etl/extract/list-outlook-conversation
    props:
      OUTLOOK_API_KEY: ${secrets.copilot-outlook-oauth}
      conversationId: ${each}
      top: 100

  extract-outlook-conversation-info:
    description: |
      Wendet primary_key_regex und message_regex (Array) auf alle Nachrichten der Konversation an;
      bei message_regex werden alle Muster nacheinander getestet, der erste Treffer wird verwendet;
      bei fehlendem Treffer wird der gesamte Nachrichtentext verwendet.
      Gibt primaryKey und messages zurück (content, index, from, role, direction, regex_extraction).
      direction: incoming = von außen, outgoing = vom Listener; letzter Eintrag = neueste Nachricht.
      regex_extraction: no_regex | no_match | matched_empty | matched (nur bei gesetztem message_regex).
    foreach: ${get-outlook-unanswered.unansweredConversationIds}
    runtime: python3_10
    code: |
      import re
      def handler(inputs):
          conversation_messages = inputs.get("conversationMessages") or []
          primary_key_regex = inputs.get("primary_key_regex") or ""
          message_regex_list = inputs.get("message_regex") or []
          if isinstance(message_regex_list, str):
              message_regex_list = [message_regex_list] if message_regex_list else []
          listener_email = (inputs.get("listenerEmail") or "").strip().lower()
          primary_key = ""
          messages = []
          latest_inbound_received = ""
          latest_inbound_message_id = ""
          print(f"[extract-outlook-conversation-info] inputs keys: {list(inputs.keys())}, conversationMessages count: {len(conversation_messages)}, listenerEmail: {listener_email!r}")
          for idx, msg in enumerate(conversation_messages):
              body = msg.get("body")
              content = body if isinstance(body, str) else ((body or {}).get("content") or "")
              content_preview = (content[:80] + "…") if len(content) > 80 else content
              print(f"[extract-outlook-conversation-info] msg[{idx}] body type={type(body).__name__}, content len={len(content)}, preview={content_preview!r}")
              if message_regex_list:
                  m = None
                  for message_regex in message_regex_list:
                      if not message_regex:
                          continue
                      m = re.search(message_regex, content, re.MULTILINE | re.DOTALL)
                      if m is not None:
                          break
                  if m is None:
                      part = content
                      regex_extraction = "no_match"
                      print(f"[extract-outlook-conversation-info] msg[{idx}] message_regex: no_match (no pattern matched), using full content len={len(part)}")
                  else:
                      part = (m.group(1) if m.groups() else m.group(0)).strip()
                      if part:
                          regex_extraction = "matched"
                          print(f"[extract-outlook-conversation-info] msg[{idx}] message_regex: matched, extracted part len={len(part)}")
                      else:
                          regex_extraction = "matched_empty"
                          print(f"[extract-outlook-conversation-info] msg[{idx}] message_regex: matched_empty (regex matched but captured text is empty), part len=0")
              else:
                  part = content
                  regex_extraction = "no_regex"
              from_obj = msg.get("from") or {}
              email_addr = (from_obj.get("emailAddress") or {}).get("address") or from_obj.get("address") or ""
              received_dt = (msg.get("receivedDateTime") or "").strip()
              sent_dt = (msg.get("sentDateTime") or "").strip()
              if received_dt and sent_dt:
                  is_outgoing = (received_dt == sent_dt)
                  print(f"[extract-outlook-conversation-info] msg[{idx}] receivedDateTime={received_dt!r}, sentDateTime={sent_dt!r}, equal=>outgoing: {is_outgoing}")
              else:
                  is_outgoing = bool(listener_email and email_addr.lower() == listener_email)
                  print(f"[extract-outlook-conversation-info] msg[{idx}] no received/sent dates, fallback by listenerEmail: from={email_addr!r}, is_outgoing={is_outgoing}")
              role = "assistant" if is_outgoing else "user"
              direction = "outgoing" if is_outgoing else "incoming"
              if not is_outgoing and received_dt and (not latest_inbound_received or received_dt > latest_inbound_received):
                  latest_inbound_received = received_dt
                  latest_inbound_message_id = (msg.get("id") or "").strip()
              messages.append({"content": part, "index": idx, "from": email_addr or None, "role": role, "direction": direction, "regex_extraction": regex_extraction})
              if not primary_key and primary_key_regex:
                  pk = re.search(primary_key_regex, content, re.MULTILINE | re.DOTALL)
                  if pk:
                      primary_key = pk.group(1) if pk.groups() else pk.group(0)
                      print(f"[extract-outlook-conversation-info] primary_key extracted at msg[{idx}]: {primary_key!r}")
          print(f"[extract-outlook-conversation-info] result: primaryKey={primary_key!r}, messages count={len(messages)}, latestInboundMessageId={latest_inbound_message_id!r}")
          return {"primaryKey": primary_key, "messages": messages, "latestInboundMessageId": latest_inbound_message_id}
    props:
      conversationMessages: ${get-outlook-conversation[each.index].messages}
      primary_key_regex: ${inputs.primary_key_regex}
      message_regex: ${inputs.message_regex}
      listenerEmail: ${inputs.listenerEmail}

  fetch-airtable-data-outlook:
    if:
      "!!": ${inputs.airtable_base_id}
    description: |
      Holt Airtable-Daten für jede Konversation anhand des extrahierten Primary Key.
    foreach: ${extract-outlook-conversation-info[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: GET
      url: https://api.airtable.com/v0/${inputs.airtable_base_id}/${inputs.airtable_table_id}
      headers:
        Authorization: Bearer ${secrets.copilot-airtable-api-key}
      params:
        filterByFormula: "{${inputs.airtable_filter_field}} = '${each.primaryKey}'"

  generate-ai-responses-outlook:
    description: |
      Ruft Copilot-API getReplyToMessage auf (threadId, listenerId, conversationHistory, optional primaryKey/airtableData).
      Die KI antwortet auf die letzte Nachricht in conversationHistory; messageId wird nicht benötigt.
    foreach: ${get-outlook-unanswered.unansweredConversationIds}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: POST
      url: ${meta.apiUrl}/copilot/generate-response
      headers:
        Authorization: Bearer ${meta.executionToken}
        Content-Type: application/json
      body:
        threadId: ${each}
        listenerId: ${inputs.listenerId}
        conversationHistory: ${extract-outlook-conversation-info[each.index].messages}
        primaryKey: ${extract-outlook-conversation-info[each.index].primaryKey}
        airtableData: ${fetch-airtable-data-outlook[each.index].response.data}

  prepare-outlook-draft-content:
    description: |
      Mappt AI-Antwort auf Entwurf-Inhalt: reply als body, categories-Objekt auf displayNames (name:value),
      damit sie mit ensure-outlook-categories übereinstimmen (keine ID-Mapping nötig).
      Akzeptiert Copilot-API-Format (reply, parsedJson) oder direkt (reply, categories).
    foreach: ${generate-ai-responses-outlook[*]}
    runtime: python3_10
    code: |
      def handler(inputs):
          ai_response = inputs.get("aiResponse") or {}
          original_message_id = (inputs.get("originalMessageId") or "").strip()
          conversation_id = (inputs.get("conversationId") or "").strip()
          body = (ai_response.get("reply") or "").strip()
          cats_obj = ai_response.get("categories")
          if cats_obj is None and "parsedJson" in ai_response:
              pj = ai_response.get("parsedJson") or {}
              cats_obj = pj.get("categories") if isinstance(pj, dict) else pj
          categories = []
          if isinstance(cats_obj, dict):
              for name, value in cats_obj.items():
                  if name and value:
                      categories.append(str(name).strip() + ":" + str(value).strip())
          return {
              "body": body,
              "categories": categories,
              "originalMessageId": original_message_id,
              "conversationId": conversation_id,
          }
    props:
      aiResponse: ${each.response.data}
      originalMessageId: ${extract-outlook-conversation-info[each.index].latestInboundMessageId}
      conversationId: ${get-outlook-unanswered.unansweredConversationIds[each.index]}

  create-outlook-reply-draft:
    description: |
      Erstellt den Reply-Entwurf (Graph createReply). createReply nimmt keinen Body;
      Body/Kategorien werden im nächsten Schritt per PATCH gesetzt.
    foreach: ${prepare-outlook-draft-content[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: POST
      url: https://graph.microsoft.com/v1.0/me/messages/${each.originalMessageId}/createReply
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      body: {}

  update-outlook-draft:
    description: |
      Setzt Body und Kategorien auf dem Entwurf.
    foreach: ${create-outlook-reply-draft[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: PATCH
      url: https://graph.microsoft.com/v1.0/me/messages/${each.response.data.id}
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      body:
        body:
          contentType: HTML
          content: ${prepare-outlook-draft-content[each.index].body}
        categories: ${prepare-outlook-draft-content[each.index].categories}
