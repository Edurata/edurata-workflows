name: kleinanzeigen-auto-reply
apiRevision: edurata.io/v1
description: |
  Durchsucht regelmäßig den Mail-Eingang nach neuen Nachrichten von kleinanzeigen.de ohne Tag,
  analysiert die Konversation mit OpenAI und erstellt automatisch eine passende Antwort als Entwurf.
  Holt genehmigte Nachrichten und sendet sie via Gmail oder Outlook.

interface:
  inputs:
    type: object
    properties:
      fromDomain:
        type: string
        default: mail.kleinanzeigen.de
        description: Domain to filter emails from (e.g., mail.kleinanzeigen.de will match anything@mail.kleinanzeigen.de)
      maxResults:
        type: integer
        default: 10
        description: Maximum number of emails to retrieve
      airtable_base_id:
        type: string
        description: Airtable base ID to fetch data from
      airtable_table_id:
        type: string
        description: Airtable table ID to fetch data from
      airtable_filter_field:
        type: string
        default: threadId
        description: Field name in Airtable to filter by (e.g., 'threadId', 'messageId', or 'email')
      primary_key_regex:
        type: string
        description: Regex pattern with a capturing group to extract the primary key from email body (e.g., 'Anzeige-ID:\\s*([A-Z0-9]+)')
      message_regex:
        type: string
        description: Regex pattern with a capturing group to extract the message content from email body (e.g., 'Nachricht:\\s*(.+?)(?:\\n\\n|$)')
      listenerId:
        type: string
        description: ID of the copilot listener that triggered this workflow execution
      userInfo:
        type: string
        description: User information to use for the response
      customCategories:
        type: array
        items:
          type: object
          properties:
            name:
              type: string
              description: Category name
            description:
              type: string
              description: Category description
            possibleValues:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                    description: Possible value name
                  color:
                    type: string
                    description: Possible value color
        description: Custom categories to add to the draft
  outputs:
    type: object
    properties: {}
steps:
  ensure-outlook-categories:
    if:
      all:
        - ===: [${inputs.emailProvider}, OUTLOOK]
        - "!!": ${inputs.customCategories}
    description: |
      Erstellt fehlende Outlook-Kategorien im Format name:value aus customCategories (lazy),
      damit sie beim Entwurf-Erstellen verfügbar sind.
    runtime: python3_10
    code: |
      import json
      import urllib.request
      import urllib.error
      def handler(inputs):
          custom_categories = inputs.get("customCategories") or []
          token = (inputs.get("outlook_api_key") or "").strip()
          if not token or not custom_categories:
              return {"created": [], "existing": []}
          base = "https://graph.microsoft.com/v1.0/me/outlook/masterCategories"
          headers = {"Authorization": "Bearer " + token, "Content-Type": "application/json"}
          existing = set()
          try:
              req = urllib.request.Request(base, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  data = json.loads(resp.read().decode())
              for c in data.get("value", []):
                  existing.add((c.get("displayName") or "").strip())
          except Exception:
              pass
          desired = []
          for cat in custom_categories:
              cat_name = (cat.get("name") or "").strip()
              if not cat_name:
                  continue
              for pv in (cat.get("possibleValues") or []):
                  val_name = (pv.get("name") or "").strip() if isinstance(pv, dict) else str(pv).strip()
                  if not val_name:
                      continue
                  display_name = cat_name + ":" + val_name
                  color = (pv.get("color") or "preset0").strip() if isinstance(pv, dict) else "preset0"
                  if not color.startswith("preset"):
                      color = "preset0"
                  desired.append((display_name, color))
          created = []
          for display_name, color in desired:
              if display_name in existing:
                  continue
              try:
                  body = json.dumps({"displayName": display_name, "color": color}).encode()
                  req = urllib.request.Request(base, data=body, headers=headers, method="POST")
                  with urllib.request.urlopen(req) as resp:
                      created.append(display_name)
                      existing.add(display_name)
              except urllib.error.HTTPError as e:
                  if e.code != 409:
                      raise
              except Exception:
                  pass
          return {"created": created, "existing": list(existing)}
    props:
      customCategories: ${inputs.customCategories}
      outlook_api_key: ${secrets.copilot-outlook-oauth}

  get-outlook-unanswered:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Holt unbeantwortete Outlook-Nachrichten von der Absender-Domain (ohne Entwurf und ohne gesendete Antwort).
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: etl/load/list-outlook-unanswered
    props:
      OUTLOOK_API_KEY: ${secrets.copilot-outlook-oauth}
      senderDomain: ${inputs.fromDomain}
      top: ${inputs.maxResults}

  get-outlook-conversation:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Holt alle Nachrichten einer Konversation (Thread) per Microsoft Graph API.
    foreach: ${get-outlook-unanswered.messages}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: GET
      url: https://graph.microsoft.com/v1.0/me/messages
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      params:
        $filter: "conversationId eq '${each.conversationId}'"
        $select: id,body,from,receivedDateTime,subject
        $orderby: receivedDateTime asc
        $top: 100

  extract-outlook-conversation-info:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Wendet primary_key_regex und message_regex auf alle Nachrichten der Konversation an;
      bei fehlendem Treffer wird der gesamte Nachrichtentext verwendet.
    foreach: ${get-outlook-unanswered.messages}
    runtime: python3_10
    code: |
      import re
      def handler(inputs):
          conversation_messages = inputs.get("conversationMessages") or []
          primary_key_regex = inputs.get("primary_key_regex") or ""
          message_regex = inputs.get("message_regex") or ""
          primary_key = ""
          message_contents = []
          for msg in conversation_messages:
              body = msg.get("body")
              content = body if isinstance(body, str) else ((body or {}).get("content") or "")
              if message_regex:
                  m = re.search(message_regex, content, re.MULTILINE | re.DOTALL)
                  part = (m.group(1) if m and m.groups() else (m.group(0) if m else content)).strip() if m else content
              else:
                  part = content
              message_contents.append(part)
              if not primary_key and primary_key_regex:
                  pk = re.search(primary_key_regex, content, re.MULTILINE | re.DOTALL)
                  if pk:
                      primary_key = pk.group(1) if pk.groups() else pk.group(0)
          combined_text = "\n\n---\n\n".join(message_contents)
          return {"primaryKey": primary_key, "combinedText": combined_text, "messageContents": message_contents}
    props:
      conversationMessages: ${get-outlook-conversation[each.index].response.data.value}
      primary_key_regex: ${inputs.primary_key_regex}
      message_regex: ${inputs.message_regex}

  fetch-airtable-data-outlook:
    if:
      all:
        - ===: [${inputs.emailProvider}, OUTLOOK]
        - "!!": ${inputs.airtable_base_id}
    description: |
      Holt Airtable-Daten für jede Konversation anhand des extrahierten Primary Key.
    foreach: ${extract-outlook-conversation-info[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: GET
      url: https://api.airtable.com/v0/${inputs.airtable_base_id}/${inputs.airtable_table_id}
      headers:
        Authorization: Bearer ${secrets.copilot-airtable-api-key}
      params:
        filterByFormula: "{${inputs.airtable_filter_field}} = '${each.primaryKey}'"

  prepare-outlook-chatgpt-prompt:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Baut System- und Nutzer-Prompt: Konversation, optional Airtable aus fetch-airtable-data-outlook,
      immer userInfo; bei customCategories wird Antwort inkl. Kategorien (summary, reply, categories) verlangt.
    foreach: ${get-outlook-unanswered.messages}
    runtime: python3_10
    code: |
      import json
      def handler(inputs):
          combined_text = inputs.get("combinedText") or ""
          primary_key = (inputs.get("primaryKey") or "").strip()
          airtable_data = inputs.get("airtableData")
          user_info = (inputs.get("userInfo") or "").strip()
          custom_categories = inputs.get("customCategories") or []
          message_parts = [combined_text]
          if user_info:
              message_parts.append("Informationen zur Beantwortung (bitte nutzen):\n" + user_info)
          if primary_key and airtable_data is not None:
              airtable_str = json.dumps(airtable_data, ensure_ascii=False) if isinstance(airtable_data, dict) else str(airtable_data)
              message_parts.append("Airtable-Daten (Primary Key: " + primary_key + "):\n" + airtable_str)
          message = "\n\n---\n\n".join(message_parts)
          system_parts = [
              "Du bist ein hilfreicher Assistent. Analysiere die folgende E-Mail-Konversation und:",
              "1. Formuliere eine passende, freundliche Antwort (reply). Nutze dazu die oben angegebenen Informationen zur Beantwortung.",
              "2. Fasse die aktuelle Konversation kurz zusammen (summary).",
          ]
          if custom_categories and len(custom_categories) > 0:
              cat_names = [c.get("name") or "" for c in custom_categories]
              cat_desc = []
              for c in custom_categories:
                  name = c.get("name") or ""
                  desc = (c.get("description") or "").strip()
                  vals = c.get("possibleValues") or []
                  val_names = [v.get("name") if isinstance(v, dict) else str(v) for v in vals]
                  s = "- " + name + (": " + desc if desc else "") + ((" (Mögliche Werte: " + ", ".join(val_names) + ")") if val_names else "")
                  cat_desc.append(s)
              system_parts.append("3. Ordne die Konversation den folgenden Kategorien zu (categories): " + ", ".join(cat_names) + ".\n" + "\n".join(cat_desc))
              system_parts.append('Antworte ausschließlich mit einem JSON-Objekt mit genau drei Schlüsseln: "reply" (Antworttext), "summary" (Kurzfassung), "categories" (Objekt mit Kategoriename als Schlüssel und gewähltem Wert als String).')
          else:
              system_parts.append('Antworte ausschließlich mit einem JSON-Objekt mit genau zwei Schlüsseln: "reply" (Antworttext) und "summary" (Kurzfassung).')
          system_message = "\n".join(system_parts)
          return {"systemMessage": system_message, "message": message}
    props:
      combinedText: ${extract-outlook-conversation-info[each.index].combinedText}
      primaryKey: ${extract-outlook-conversation-info[each.index].primaryKey}
      airtableData: ${fetch-airtable-data-outlook[each.index].response.data}
      userInfo: ${inputs.userInfo}
      customCategories: ${inputs.customCategories}

  generate-ai-responses-outlook:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Ruft ChatGPT direkt auf: gute Antwort, Kurzfassung und ggf. Kategorien (kein interner API-URL).
    foreach: ${get-outlook-unanswered.messages}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: etl/transform/chatgpt
    props:
      API_KEY: ${secrets.copilot-openai-api-key}
      model: gpt-4o
      parseResponseToJson: true
      systemMessage: ${prepare-outlook-chatgpt-prompt[each.index].systemMessage}
      message: ${prepare-outlook-chatgpt-prompt[each.index].message}

  prepare-outlook-draft-content:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Mappt AI-Antwort auf Entwurf-Inhalt: reply als body, categories-Objekt auf displayNames (name:value),
      damit sie mit ensure-outlook-categories übereinstimmen (keine ID-Mapping nötig).
    foreach: ${generate-ai-responses-outlook[*]}
    runtime: python3_10
    code: |
      def handler(inputs):
          ai_response = inputs.get("aiResponse") or {}
          original_message_id = (inputs.get("originalMessageId") or "").strip()
          conversation_id = (inputs.get("conversationId") or "").strip()
          processed_label = (inputs.get("processedLabel") or "").strip()
          body = (ai_response.get("reply") or "").strip()
          cats_obj = ai_response.get("categories")
          categories = [processed_label] if processed_label else []
          if isinstance(cats_obj, dict):
              for name, value in cats_obj.items():
                  if name and value:
                      categories.append(str(name).strip() + ":" + str(value).strip())
          return {
              "body": body,
              "categories": categories,
              "originalMessageId": original_message_id,
              "conversationId": conversation_id,
          }
    props:
      aiResponse: ${each.response}
      originalMessageId: ${get-outlook-unanswered.messages[each.index].id}
      conversationId: ${get-outlook-unanswered.messages[each.index].conversationId}
      processedLabel: ${inputs.processedLabel}

  create-outlook-reply-draft:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Erstellt den Reply-Entwurf (Graph createReply).
    foreach: ${prepare-outlook-draft-content[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: POST
      url: https://graph.microsoft.com/v1.0/me/messages/${each.originalMessageId}/createReply
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      body: {}

  update-outlook-draft:
    if:
      ===:
        - ${inputs.emailProvider}
        - OUTLOOK
    description: |
      Setzt Body, Kategorien und isReplyTo auf dem Entwurf (kein extensionMetadata).
    foreach: ${create-outlook-reply-draft[*]}
    source:
      repoUrl: "https://github.com/Edurata/edurata-functions.git"
      path: general/axios
    props:
      method: PATCH
      url: https://graph.microsoft.com/v1.0/me/messages/${each.response.data.id}
      headers:
        Authorization: Bearer ${secrets.copilot-outlook-oauth}
        Content-Type: application/json
      body:
        body:
          contentType: HTML
          content: ${prepare-outlook-draft-content[each.index].body}
        categories: ${prepare-outlook-draft-content[each.index].categories}
        singleValueExtendedProperties:
          - id: "String {66f5a359-4659-4830-9070-00047ec6ac6e} Name isReplyTo"
            value: ${prepare-outlook-draft-content[each.index].originalMessageId}

